name: Release

on:
  push:
    branches: [main]
  workflow_dispatch:
    inputs:
      bump_override:
        description: "Force bump type (auto uses commit messages)"
        required: true
        type: choice
        options:
          - auto
          - patch
          - minor
          - major
        default: auto

permissions:
  contents: write

concurrency:
  group: release-main
  cancel-in-progress: false

jobs:
  release:
    name: Create Tag and Release
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Determine next semantic version
        id: version
        shell: bash
        env:
          BUMP_OVERRIDE: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.bump_override || 'auto' }}
        run: |
          set -euo pipefail

          git fetch --tags --force

          LAST_TAG="$(git tag -l 'v*' --sort=-v:refname | head -n 1 || true)"
          BASE_VERSION="0.0.0"
          RANGE="HEAD"

          if [ -n "$LAST_TAG" ]; then
            BASE_VERSION="${LAST_TAG#v}"
            RANGE="${LAST_TAG}..HEAD"
          fi

          if [ -n "$LAST_TAG" ]; then
            COMMIT_COUNT="$(git rev-list --count "${LAST_TAG}..HEAD")"
          else
            COMMIT_COUNT="$(git rev-list --count HEAD)"
          fi

          if [ "${COMMIT_COUNT}" = "0" ]; then
            echo "skip=true" >> "$GITHUB_OUTPUT"
            echo "No new commits since last release."
            exit 0
          fi

          COMMITS="$(git log --format=%B ${RANGE})"
          BUMP="patch"

          if [ "${BUMP_OVERRIDE}" != "auto" ]; then
            BUMP="${BUMP_OVERRIDE}"
          else
            if echo "${COMMITS}" | grep -Eqi 'BREAKING CHANGE|!:'; then
              BUMP="major"
            elif echo "${COMMITS}" | grep -Eqi '^feat(\(.+\))?:'; then
              BUMP="minor"
            fi
          fi

          IFS='.' read -r MAJOR MINOR PATCH <<< "${BASE_VERSION}"
          MAJOR="${MAJOR:-0}"
          MINOR="${MINOR:-0}"
          PATCH="${PATCH:-0}"

          case "$BUMP" in
            major)
              MAJOR=$((MAJOR + 1))
              MINOR=0
              PATCH=0
              ;;
            minor)
              MINOR=$((MINOR + 1))
              PATCH=0
              ;;
            patch)
              PATCH=$((PATCH + 1))
              ;;
            *)
              echo "Invalid bump type: $BUMP"
              exit 1
              ;;
          esac

          NEW_TAG="v${MAJOR}.${MINOR}.${PATCH}"
          if git rev-parse "${NEW_TAG}" >/dev/null 2>&1; then
            echo "skip=true" >> "$GITHUB_OUTPUT"
            echo "Tag ${NEW_TAG} already exists."
            exit 0
          fi

          echo "skip=false" >> "$GITHUB_OUTPUT"
          echo "new_tag=${NEW_TAG}" >> "$GITHUB_OUTPUT"
          echo "base_tag=${LAST_TAG}" >> "$GITHUB_OUTPUT"
          echo "bump=${BUMP}" >> "$GITHUB_OUTPUT"

      - name: Create git tag
        if: steps.version.outputs.skip == 'false'
        shell: bash
        run: |
          set -euo pipefail
          TAG="${{ steps.version.outputs.new_tag }}"
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git tag -a "${TAG}" -m "release: ${TAG}"
          git push origin "${TAG}"

      - name: Create GitHub release with notes
        if: steps.version.outputs.skip == 'false'
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.version.outputs.new_tag }}
          generate_release_notes: true
